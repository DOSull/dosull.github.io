---
title: "NetLogo is weird as hell"
subtitle: "Also: fantastic"
description: |
   NetLogo is a platform for making agent- and/or cell-based models. Its syntax is weird, its atomic elements are 'turtles' and 'patches', and it would very much prefer that you not use for loops. In spite of all that it's a great tool to think with, which is why I love it.
from: markdown+emoji
author: "David O'Sullivan"
toc: true
lightbox:
  match: auto
code-annotations: hover
code-fold: show
filters: 
  - nutshell
categories:
  - netlogo
  - simulation
execute:
  cache: true
freeze: auto
knitr:
  opts_chunk: 
    warning: false
    message: false
date: 02-02-2026
draft: true
draft-mode: unlinked
---

Just lately, I've had reason to mock up a couple of simple models of opinion dynamics, and its caused me to spend some time working on _new_ [NetLogo](https://www.netlogo.org/) code,^[_New_ is important here, but I'll get to that.] which I always find to be a joy. The models are from Thurner et al. 2025[^1] and Mathias et al.[^2]

![NetLogo implementation of Thurner et al. 2025.](thurner-et-al-2025-interface.png){#fig-thurner-et-al}

![NetLogo implementation of Mathias et al. 2020.](mathias-et-al-2017-interface.png){#fig-mathias-et-al}

[^1]: See: Thurner S, M Hofer, and J Korbel. 2025. [Why more social interactions lead to more polarization in societies](https://pnas.org/doi/10.1073/pnas.2517530122). _Proceedings of the National Academy of Sciences_ **122**(44) e2517530122.

[^2]: See: Mathias J-D, JM Anderies, J Baggio, J Hodbod, S Huet, MA Janssen, M Milkoreit, and M Schoon. 2020. [Exploring non-linear transition pathways in social-ecological systems](https://www.nature.com/articles/s41598-020-59713-w). _Scientific Reports_ **10**(1) 4136. Although it's worth noting that Challis KJ. 2026. [An aggregate potential landscape description of an agent-based exploitation-perception model for social-ecological tipping-point dynamics](https://dx.doi.org/10.1016/j.ecolmodel.2025.111433). _Ecological Modelling_ **513** 111433 describes the model better.

It doesn't much matter what these models are about. What I'm interested in here is what makes NetLogo a great platform for a situation where, as here, I've just read about a model, and perhaps I don't quite get it. Or I want to know more. Or I want to know what would happen if I changed something. For that, I need to build it. It might be my engineering background (my first degree) that means I learn by building, or maybe I just enjoy the process. Either way, there really isn't a better tool for this approach to exploring these kinds of systems.

Thinking about this question is useful in a more general sense for thinking about what makes any programming languagage useful.

Before I get to that, some personal history. If you're not interested in my backstory and just want to know why NetLogo is great jump to [that section](#what-makes-netlogo-great), I won't be offended.


## My NetLogo journey
I wrote a lot of code for a tool I called _GraphCA_ in Java for my PhD&mdash;. In fact,[`cloc`](https://github.com/AlDanial/cloc) informs me thus:

    ----------------------------------------------------
    Language    files      blank    comment       code
    ----------------------------------------------------
    HTML          128       4350       1591      47599
    Java          101       3035       4232       8634
    Text            2          4          0         19
    CSS             1          8          8         13
    ----------------------------------------------------
    SUM:          232        7397      5831      56265
    ----------------------------------------------------

8634 lines of actual code (not comments, but over 4000 lines of those too). Being Java a ton of files too, 101 of them defining 101 or more classes!^[Thankfully, all that HTML was generated by `javadoc`.]

While I was labouring to learn Java and build my own GUI and plotting tools, and so on, my advisor [Mike Batty](https://profiles.ucl.ac.uk/11266-michael-batty) spent much of the time churning out interesting models (and papers) using something called [StarLogo](https://en.wikipedia.org/wiki/StarLogo). Needless to say I thought I was the future and Mike was a crazy old man messing about with a weird child's toy.

StarLogo was an evolution of [Logo](https://en.wikipedia.org/wiki/Logo_(programming_language)) a LISP-like programming language. Logo is a 'proper' programming language, which is (perhaps unfairly) best known for its use of [_turtle graphics_](https://en.wikipedia.org/wiki/Turtle_graphics), which is computer graphics based on issuing instructions to a pen-carrying turtle to move around the screen (`forward 100`, `right 90`, that kind of thing) and draw stuff (`pen-up`, `pen-down`, `set color red`, and so on). In essence, StarLogo is what you get if you ask (and answer) the question, "what about if I had _many_ turtles?", and supplementary question, "what about if they could interact with each other?" StarLogo, was originally developed by [Mitch Resnick](https://en.wikipedia.org/wiki/Mitchel_Resnick) and is nicely described in _Turtles, Termites, and Traffic Jams_[^tttj] Since its original development StarLogo has stuck close to its educational mission and evolved into a building block based programming environment clearly aimed at early education settings, although [lately development seems to have slowed down](https://www.slnova.org/). 

[^tttj]: Resnick M. 1994. _Turtles, Termites, and Traffic Jams: Explorations in Massively Parallel Microworlds_. MIT Press.

NetLogo was originally effectively a clone of StarLogo developed at the [Center for Connected Learning at Northwestern](https://ccl.northwestern.edu/). There was a strange period in the late 1990s into the early 2000s when several *Logo variants were competing for attention. I'm not really sure what their beef was with one another, although an immediate advantage of NetLogo was that being written in Java it could be run on a PC. Whatever the reason for competing *Logos, eventually NetLogo won out in the application I'm interested in of using NetLogo to build models of distributed systems, most often agent-based or cell-based.

But it took for me to see what Mike Batty saw in the platform. I stuck with Java well past the point where I had time to develop Java code,[^3] and persisted with building agent-based models using [Repast](https://repast.github.io/repast_simphony.html).[^4]

[^3]: What they say is true: you'll never have as much time to dig into things once you start an academic job as you do when you are doing your PhD.

[^4]:George Perry has never really forgiven me for persuading him to write a model of fish population dynamics using Repast. See Perry GLW and NR Bond. 2009. [Spatially explicit modeling of habitat dynamics and fish population persistence in an intermittent lowland stream](https://dx.doi.org/10.1890%2F08-0651.1). _Ecological Applications_ **19**(3) 731â€“746.

Although I had already used NetLogo quite a bit by then, I still had a residual sense that it wasn't a serious tool. My moment of clarity arrived while on sabbatical in 2008 at the [National Centre for Geocomputation](https://www.maynoothuniversity.ie/national-centre-geocomputation-ncg) in Ireland. I planned to use the software from my PhD to support some arguments I was making in a talk I was to give. But when I went to run it the day before the talk on the by-then 3 or 4 laptops later than the machine it was originally written on, I couldn't get it to work. After trying and failing for several hours,^[I have since run it successfully, so I don't really know what was wrong.] I gave up and decided to see if I could reimplement the essentials of _GraphCA_ using NetLogo. 

Well... 250 or so lines of NetLogo code later and I was back in business. From 8600 lines of Java to 250 lines of NetLogo! The NetLogo version doesn't do everything my Java code did, and I don't need it to. I suspect another 250 lines would do the trick. In any case I haven't even considered writing another line of Java code since. Of course, I use other languages than NetLogo (R and Python) all the time, but for building simulations, and more generally for interactively exploring spatial ideas, I often turn to NetLogo.

![The interface of my game-changing NetLogo model of a graph-CA.](gca-2023-interface.png){#fig-gca-nlogo}


## What makes NetLogo great
So what's so great about NetLogo?

### It's turtles (and patches) all the way down
The essential primitives of NetLogo, other than the usual numbers and strings are _turtles_ and _patches_. It also has _links_ (between turtles) and _lists_ (same as lists in other languages), but turtles and patches are the core of it. 

When you open NetLogo there is a square **View** which on closer inspection is a 33&times;33 grid of patches. And into this 'world' you can add turtles with `create-turtles`. And you are then in a position to `ask` them to do stuff. The commands

    ask patches [ set pcolor random 3 ]
    create-turtles 500 [ forward random-float 15 ]

will produce this picture in the view:

![500 turtles that have moved forward from the centre of the view.](500-turtles.png){#fig-500-turtles}

The central iteration command in NetLogo is not a for loop (although it has those if you need them). Instead, it is politely `ask`ing _patchsets_ and _turtlesets_ to do things. The default collection of all turtles in a model is called `turtles`, and all the patches are called, well... `patches`. So 

    ask patches [ set pcolor random 3 ]
    
gets all the patches to set a colour specified by one of the values 0, 1, or 2, chosen at random. Also, in the example above the block of code enclosed in `[...]` after the `create-turtles` command will be executed by each turtle on creation. 

The `ask` operator iterates over sets in _random order_. This is at first confusing if you are accustomed to for loops and iterating over arrays and lists,^[So much so that Python has gone out of its way to guarantee order when iterating over ostensibly unordered collections like its dictionary objects.] but you get used to it, and it's an important feature in simulation contexts, where always having patches or turtles execute in the same order can produce undesirable behavioural artifacts.

In addition to their built-in properties (things like colour, size, coordinate locations) turtles and patches can have properties assigned to them, and can thus be used to represent mobile entities or fixed locations with a range of characteristics. If you only want some of the turtles or patches do something, then you use `with` conditional clauses to filter the set:

    create-turtles 500 [ set color one-of [orange blue] ]
    ask turtles [forward 5]
    ask turtles with [color = blue] [forward 5]

![Turtles after they all moved `forward 5` and only those `with [color = blue]` moved `forward 5` again.](orange-blue-turtles.png){#fig-orange-blue-turtles}

This isn't the place to learn NetLogo, so I won't get into any more details than this. The reason this is great is that these primitives come for free. It's no work at all to create, visualize, and manipulate mobile entities and grid cells. Agents and grids are not built in primitives in other languages, and representing them graphically is often more work again. The closest analogue to this behaviour in another programming language is [processing](https://processing.org/).

### Visualization and GUI for free
Turtles and patches are immediately graphically represented in the view. As your model runs, you see it evolve, without any additional effort. You can focus on choosing colours and shape to represent different entity states and not on visualization code to achieve this. The following is all the code needed for a voter model in NetLogo:

    to setup
      clear-all
      ask patches [ set pcolor one-of [red yellow blue] ]
      reset-ticks
    end

    to go
      ask patches [ set pcolor [pcolor] of one-of neighbors4 ]
      tick
    end

The `reset-ticks` and `tick` commands aren't required but help with controlling display updating.

NetLogo also has GUI elements for free: buttons, sliders, drop-downs, switches and so on. Functions (called _procedures_ and _reporters_ in NetLogo) can be associated with GUI elements. So if we add `setup` and `go` buttons to the GUI, then we end up with a model like this one (did I mention it also has the option to export models to web pages?)

<iframe src="voter-model.html" width=100% height=500px></iframe>

The only comparably simple GUI experience I've come across was [Visual Basic](https://en.wikipedia.org/wiki/Visual_Basic_(classic)) and for all kinds of other reasons I have no desire to go back there.

### Its semantics, stupid
```netlogo
ask turtles [
  move-to one-of neighbors4
]
```

### NetLogo has made me a better programmer
List operations `map` and `reduce`


## Downsides
### Nobody takes it seriously
The kid's toy delusion is a problem

### Development tools


