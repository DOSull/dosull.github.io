---
title: "XKCD 3122 'Interrupted spheres'"
subtitle: "Now with added New Zealand"
description: |
   Soon after I posted my definitive ranking of xkcd's bad map projections, another was added to the pile. I've reverse-engineered it in R, so you don't have to.
from: markdown+emoji
author: "David O'Sullivan"
toc: true
lightbox:
  match: auto
code-annotations: hover
code-fold: show
filters:
  - nutshell
categories:
  - xkcd
  - cartography
  - R
  - tutorial
  - stuff
  - geospatial
execute:
  cache: true
freeze: auto
knitr:
  opts_chunk: 
    warning: false
    message: false
date: 10-28-2025
---

Not long ago I posted my ranking of [xckd](https://xkcd.com)'s 'bad map projections' comics. Not long after that a new one appeared 'interrupted spheres' in [comic #3122](https://xkcd.com/3122). For the record, I'd place it at number 4 in my list. It's definitely a bad projection in all kinds of ways, but it is also thought provoking as I hope this post, where I reverse-engineer a version of the projection, will show.

::: {#fig-xkcd-3122 fig-cap="Alt-text: During the most recent glacial maximum, it's believed that land bridges extended from the surfaces and connected several of the spheres together."}
![](xkcd-3122-bad_map_projection_interrupted_spheres_2x.png)
:::

```{r}
#| label: imports
#| output: false
#| code-fold: true
library(sf)
library(units)
library(dplyr)
library(stringr)
library(smoothr)
library(geosphere)
library(ggplot2)
library(patchwork)
library(kableExtra)
```

One thing to note about the data in this post is that I made the file from two Natural Earth datasets&mdash;the [countries data at 1:110M](https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/cultural/ne_110m_admin_0_countries_lakes.zip) differenced with the [lakes at 1:110M](https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/physical/ne_110m_lakes.zip). This is because the countries, without the lakes, especially in North America just look wrong. By the time we are done, they'll look a whole lot wronger, but it seems advisable to start from a good place.

```{r}
#| label: read-world-data
#| output: false
#| code-fold: true
world <- st_read("world.gpkg") |>
  st_set_geometry("geometry")
```

```{r}
#| label: fig-world-map-4326
#| fig-cap: The source world data including lakes
#| fig-width: 8
#| fig-height: 4
#| code-fold: true
ggplot() + 
  geom_sf(data = world)
```
It's also worth noting that I had to repair a couple of minor issues in the data which were ultimately the root cause of some strange issues I was having running distance-based filtering. Lesson-learned: don't ignore `st_is_valid() == FALSE` problems in your data if you're planning on any analysis, but perhaps _especially_ if you are doing weird projection transformations.

## The plan
Reverse-engineering a projection is, as cartographers are fond of saying, an art and a science.^[In this case, I think both words probably over-dignify the activity.] My plan of attack as far as it went was to make a series of localised spherical views of subsets of the data, filtered based on the `CONTINENT` attribute in the dataframe. This wasn't a terrible place to start, but Russia in particular&mdash;classified as `Europe`&mdash;presents some challenges to this approach. It also turns out that my chosen local spherical projection [near-sided perspective](https://proj.org/en/stable/operations/projections/nsper.html#nsper)(NSP) frequently introduces irreparable topological errors into data. That led to a diversion via the [azimuthal equidistant projection](https://proj.org/en/stable/operations/projections/aeqd.html) to make it easier to select regions of Earth surface that approximate to continents based on distance from some central location, which reduced the topology problems.^[Perhaps even solves them, but my code has not been exhaustively tested...]

So what follows, traces the process of arriving at my approximation of the interrupted spheres projection, before assembling everything into a couple of functions that allow it to be run in a line or two of code.

We start by looking at making a single sphere.

## A single sphere
We start with a single continent. For no particular reason,^[Alphabetical is as good an order as any.] let's go with Africa.

```{r}
#| label: fig-africa-map
#| fig-cap: Africa mapped showing the graticule
#| fig-width: 6
#| fig:height: 8
africa <- world |> filter(CONTINENT == "Africa")
ggplot() +
  geom_sf(data = africa)
```

### The near-side perspective projection
The near-sided perpsective projection simulates the view from space looking directly down at a specified central point, from some specified height above Earth's surface. Here are three examples at a series of heights.

```{r}
#| label: fig-different-h-nsper-projections
#| fig-cap: The near-sided perspective projection of Africa at three different heights
#| fig-width: 8
#| fig-height: 3.2
#| code-fold: true
plots <- list()
for (h in c(1500e3, 3000e3, 6000e3)) {
  proj <- str_glue("+proj=nsper +lon_0=15 +lat_0=0 +h={h}")
  plots[[length(plots) + 1]] <- ggplot() +
    geom_sf(data = africa |> st_transform(proj)) +
    ggtitle(str_glue("From {h/1000}km")) +
    theme_void()
}
wrap_plots(plots, nrow = 1)
```

The shape distortions introduced by more close-up, lower height views appear similar to those we see in the comic map. Eventually, if you go far enough out, the NSP projection becomes the [orthographic projection's](https://proj.org/en/stable/operations/projections/ortho.html) view from infinity.

It's useful to know the radius of the circles (of the sphere) in this projection. My initial attempts to do this involved converting polygons in the projected data to points and calculating the distance of the farthest point from the centre. It turns out that the radius of the circle is directly calculable. According to Snyder^[Page 173 in Snyder PJ. 1987. _Map Projections a Working Manual_ United States Government Printing Office] (who can be trusted on such matters), this is given by

$$
r=R\sqrt{\frac{(P-1)}{(P+1)}}
$$
where $R$ is Earth's radius, $P=h/R+1$, and $h$ is the height above Earth's surface of the projection. We can make a function to return this result for an instance of the projection, or even more usefully to return a circle of that size.

```{r}
#| label: get-globe-of-nsper-projection
get_limit_of_nsper_proj <- function(h, projstring, R = 6371008) {
  P <- h / R + 1
  r <- R * sqrt((P - 1) / (P + 1))
  st_point(c(0, 0)) |>
    st_sfc() |> 
    data.frame() |>
    st_sf() |>
    st_buffer(r) |>
    densify(20) |>
    st_set_crs(projstring)
}
```

This allows us to make a map in the style of the xkcd projection (more or less).

```{r}
#| label: fig-single-sphere-map
#| fig-cap: A 'single sphere' map of Africa with the near-sided perspective height set to 2000km, and a 'globe' drawn based on the function above
#| fig-width: 6
#| fig-height: 6
#| code-fold: true
h <- 2000e3
proj <- str_glue("+proj=nsper +lon_0=15 +lat_0=0 +h={h}")
globe <- get_limit_of_nsper_proj(h, proj)
ggplot() +
  geom_sf(data = globe, fill = "grey", colour = NA) +
  geom_sf(data = africa |> st_transform(proj), fill = "white", color = "black") +
  geom_sf(data = africa |> st_transform(proj) |> st_union(), 
          fill = NA, color = "black", lwd = 0.65) +
  geom_sf(data = globe, fill = NA, colour = "black", lwd = 1) +
  theme_void()
```

### The azimuthal equidistant projection (and why we need it)
So far so good. We're halfway there already.^[Technically, since there are seven continents ([opinions vary](https://en.wikipedia.org/wiki/Continent#Number)), 1/7th of the way there.] 

As I mentioned above, selecting by continent name isn't entirely satisfactory. I could (in fact I did) edit the data to put Russia in Asia, but that felt a bit _ad hoc_, and instead I decided to base selection of shapes to include in each sub-sphere on specifying a distance on Earth's surface along with a centre point of the projection. So the included shapes would be any that fall within that distance from the centre point.

You would assume^[I certainly did.] that with ability we already have to create a circle for any given NSP projection, this would be simple enough. In practice, I found that the shapes resulting from the NSP projection, when I try to union them throw topological errors that seemed not to be repairable with `st_make_valid()`. The reason I union the shapes is to get the xkcd look where the outlines of landmasses are heavier than national boundaries. The easy option would be to not worry about that detail. I took the harder road of figuring out a workaround. 

After quite a bit of experimentation this involved selecting the world data based on a distance criterion, then transforming to a projection where it was safe to do the intersection of the globe with the selected shapes. This turned out to be an equidistant projection centred on the same spot as the NSP projection. The manual filtering by distance seems unnecessary, given the subsequent intersection step, but again, I found cases where this threw topological errors. My guess is that this would be caused by very small differences in the projected circle in the equidistant and NSP projections. In any case, the approach I have now seems not to run into such problems.^[This is all no doubt associated with floating point calculations, the perennial bugbear of all geomtery in geospatial. Don't get me started...]

Anyway, here's some code working through that process.

```{r}
#| label: code-to-make-sphere-based-on-a-search-radius-and-centre
height_for_horizon <- function(d, R = 6371008) {                    # <1> 
  R / cos(d / R) - R
}

d <- 3500e3
lon_0 <- 15
lat_0 <- 0
centre <- st_point(c(lon_0, lat_0)) |>
  st_sfc() |>
  st_set_crs(4326)
h <- height_for_horizon(d)

aeqd_proj <- str_glue("+proj=aeqd +lon_0={lon_0} +lat_0={lat_0}")  # <2>
nsper_proj <- str_glue("+proj=nsper +lon_0={lon_0} +lat_0={lat_0} +h={h}")

globe_nsper <- get_limit_of_nsper_proj(h, nsper_proj)              # <3>
globe_aeqd <- globe_nsper |>                                       # <4>
  st_transform(aeqd_proj)

shapes_to_map <- world |>
  filter(drop_units(st_distance(geometry, centre)) < d) |>         # <5>
  densify(20) |>                                                   # <6>
  st_transform(aeqd_proj) |>
  st_intersection(globe_aeqd) |>                                   # <7>
  st_transform(nsper_proj)                                         # <8>
```
1. It's useful to be able to determine the NSP height parameter given the desired radius from the central point. The formula $h=R/\cos(d/R)-R$ is easily derived by drawing the tangent to a circle from a point $h$ away from it, and doing some trigonometry.
2. This is the azimuthal equidistant projection.
3. Our local sphere...
4. ... and it transformed to an equidistant projection at the same centre point.
5. Include only shapes within the desired distance from the projection centre.
6. It is good practice with highly generalized data to densify lines when performing projections.
7. Do the necessary intersection in the equidistant projection coordinate system.
8. Convert the resulting shapes into the desired NSP projection.

And here is an output map, confirming that everything is still working.

```{r}
#| label: fig-map-from-radius-and-centre
#| fig-cap: Single sphere map produced by specifying a radius of 3500km
#| fig-width: 6
#| fig-height: 6
#| code-fold: true
ggplot() +
  geom_sf(data = globe_nsper, fill = "grey", colour = NA) +
  geom_sf(data = shapes_to_map, fill = "white") +
  geom_sf(data = shapes_to_map |> st_union(), fill = NA, lwd = 0.65) +
  geom_sf(data = globe_nsper, fill = NA, colour = "black", lwd = 1) +
  theme_void()
```
Putting all this together, we can make a function that for a given central point and specified distance returns the 'shapes' and 'globe' datasets needed to make a multi-sphere map.

```{r}
make_local_spherical_projection <- function(lon_0, lat_0, d) {
  centre <- st_point(c(lon_0, lat_0)) |>
    st_sfc() |>
    st_set_crs(4326)
  h <- height_for_horizon(d)
  aeqd_proj <- str_glue("+proj=aeqd +lon_0={lon_0} +lat_0={lat_0}")
  nsper_proj <- str_glue("+proj=nsper +lon_0={lon_0} +lat_0={lat_0} +h={h}")
  globe_nsper <- get_limit_of_nsper_proj(h, nsper_proj)
  globe_aeqd <- globe_nsper |> 
    st_transform(aeqd_proj)
  world_nsper <-
    world |> 
    filter(drop_units(st_distance(geometry, centre)) < d) |>
    densify(20) |>
    st_transform(aeqd_proj) |>
    st_intersection(globe_aeqd) |>
    st_transform(nsper_proj)
  list(shapes = world_nsper, globe = globe_nsper)
}
```

## Many spheres
Using the helper functions already written, we can now make a further function to iterate over multiple combinations of central location, radius, and a couple of other parameters (explained a little later) to give us a final map.

```{r}
#| label: make-world-map-function
make_world_map <- function(df) {
  shapes <- list()
  globes <- list()
  for (i in 1:dim(df)[1]) {
    shift <- c(df$dx[i], df$dy[i])
    a <- df$rotn[i] * pi / 180
    rot_m <- matrix(c(cos(a), sin(a), -sin(a), cos(a)), 2, 2)
    results <- do.call(make_local_spherical_projection, df[i, 2:4])
    shapes[[i]] <- 
      results$shapes |> 
      mutate(facet = df$facet[i], 
             geometry = (geometry * rot_m) + shift)
    globes[[i]] <- 
      results$globe |> 
      mutate(facet = df$facet[i], 
             geometry = (geometry * rot_m) + shift) 
  }
  shapes <- shapes |> bind_rows()
  globes <- globes |> bind_rows()
  outlines <- shapes |> group_by(facet) |> summarise()
  ggplot() +
    geom_sf(data = globes, fill = "grey", colour = NA) +
    geom_sf(data = shapes, fill = "white", colour = "black", lwd = 0.25) +
    geom_sf(data = outlines, fill = NA, colour = "black", lwd = 0.5) +
    geom_sf(data = globes, fill = NA, colour = "black", lwd = 0.75) +
    theme_void()
}
```

Here's a dataframe with settings for the required arguments.

```{r}
#| label: args-dataframe
#| code-fold: true
args <- data.frame(
  facet = c("North America", "Europe", "Asia", "South America", 
            "Africa", "Antarctica", "Oceania"),
  lon_0 = c(  -88,    12,    95,   -55,    15,   -30,   148),
  lat_0 = c(   40,    53,    35,   -18,     0,   -85,   -30),
  d     = c(4.5e6, 2.7e6, 7.0e6, 4.5e6, 5.0e6, 3.0e6, 3.8e6),
  dx    = c(-0.79, -0.11,  0.43, -0.67, -0.13,  -0.5,  0.79) * 1e7,
  dy    = c( 0.38,  0.44,  0.39, -0.09,  0.03, -0.45, -0.09) * 1e7,
  rotn  = c(    5,     0,   -25,    10,     0,   -15,     5)
)
args |> 
  kable() |> 
  kable_styling("striped", full_width = FALSE) |>
  scroll_box(height = "340px")
```

The `lon_0`, `lat_0`, and `d` columns here correspond to the arguments of the same name in the `make_local_spherical_projection` function. I've chosen centre coordinates and radii for each continent by a process of trial and error. Having realised that I had this kind of flexibility I decided not to replicate the xkcd map, but to make my own new and improved version.

The `facet` attribute is in part to help keep track of which row is which, but more importantly it used in `make_world_map` to dissolve the shapes in each sphere into a single multi-polygon which can be outlined in a thicker line xkcd-style.

Additional arguments for the final map are `dx`, `dy`, and `rotn`. These are offsets in the x and y directions and a rotation to be applied to each sphere. The units of the offsets are uncertain, since we are mixing the output from seven different projections. Nominally, everything is in metres, but given the perspectival aspect and the fact that each of the seven projections is from a different height, they are not the same metres in each sphere. So for present purposes it made more sense to experiment until I got numbers that put the different spheres where I wanted them!

And so... to a final map!

```{r}
#| label: fig-my-interrupted-spheres-map
#| fig-cap: A different interrupted spheres map with added New Zealand, and Antarctica in a more suitable location^[IMHO.]
#| fig-width: 12
#| fig-height: 9
make_world_map(args)
```

I think we can all agree this map is a considerable improvement on the original.^[No correspondence will be entered into on this matter.] I decided to have each sphere provide a more complete representation of its assigned continent. That means New Zealand is included in this map, and Iceland just sneaks in. Alaska still misses out. I feel quite strongly^[Sometimes I surprise myself.] that Antarctica in the orientation shown in the xkcd original really belongs below South America, so I moved it.

It's a fiddly process, but if you would prefer a replica of the original map, then feel free to reuse the code and modify the arguments dataframe. The worst part is that changing the area of coverage of a globe changes its size and requires changing all the positional offsets. There is certainly a better way. With any luck, some d3 guru (see the next section) will help us out.

## Polyhedral projections
Having taken this thing as far as I have it seems worth noting that there is clearly a point where these interrupted sphere projections bump into a genre of properly serious world projections, the _polyhedral projections_.^[To be fair, polyhedral world projections weren't really taken seriously until relatively recently.] 

Polyhedral projections are where a polyhedron is wrapped around the sphere and that part of Earth's surface 'covered' by each facet of the polyhedron is projected on to it, usually by [_gnomonic_ projection](https://en.wikipedia.org/wiki/Gnomonic_projection). In other words, a point on Earth surface is projected on to a facet of the enclosing polyhedron by drawing a line from the centre of Earth, through the point and on to the facet.

The [d3](https://d3js.org/) visualization platform is probably the best tool to use if you are a fan of this projection style, which is unfortunate, because I _am_ a fan, and have bounced off d3 more than once. And of course it works with its own coordinate system and doesn't play nice with the various standards for exchanging information about projections in geospatial. The results are very cool though. See for example: [this](https://observablehq.com/@fil/polyhedral-projections-with-d3-geo-polygon), [this](https://observablehq.com/@fil/dodecahedral-projection), [this](https://observablehq.com/@fil/airocean-projection), and [this](https://observablehq.com/@fil/experimental-two-world-projections). Peak polyhedrality is to be found in van Wijk's _myriahedral projections.^[See van Wijk JJ. 2008. [Unfolding the Earth: Myriahedral projections](https://dx.doi.org/10.1179/000870408X276594) _Cartographic Journal_ **45**(1) 32-42, and also [here](https://vanwijk.win.tue.nl/myriahedral).]

Anyway, I mention all this because with a bit of effort you can make a kind of 'polyspherical' (except they are obvious circles because they are flat) projection using the code I've written. Here's a dodecahedral projection:

::: {#fig-dodecahedral-projection fig-cap="A dodecahedral projection (image from [observablehq.com](https://observablehq.com/@fil/polyhedral-projections-with-d3-geo-polygon))"}
![](dodecahedral-projection.png)
:::

And here's an interrupted spheres projection arranged the same way.

```{r}
#| label: fig-interrupted-spheres-arranged-like-a-dodecahedron
#| fig-cap: Interrupted spheres making like a dodecahedron
#| fig-width: 12
#| fig-height: 8
#| code-fold: true
args2 <- data.frame(
  facet = 1:12,
  lon_0 = c(-12, -156, -84, -12, 60, 132, -120, -48, 24, 96, 168, -48),
  lat_0 = c(90, 30, 30, 30, 30, 30, -30, -30, -30, -30, -30, -90),
  d     = rep(5e6, 12),
  dx    = c(3, 1.25, 2:4, 4.75, 1:4+0.5, 5.25, 2.5) * 6.2e6,
  dy    = c(1.71, 1.1, rep(0.5, 3), 1.1, rep(-0.5, 4), -1.1, -1.71) * 4.4e6,
  rotn  = c(0, 54, rep(0, 3), -54, rep(0, 4), 54, 0)
)
make_world_map(args2)
```

## Final thoughts
Maybe, given that my criterion in ranking the xkcd bad map projections was how thought-provoking they are, this one should be even higher than my provisional #4. Grappling with reverse-engineering it forced me to look into a few interesting rabbit holes. More than anything it reinforces my sense that we really could use much more flexible architecture around map projections in geospatial. I am somewhat in awe of what has been done in the d3-verse in that regard.

With that... I look forward with some trepidation to the next time an xkcd bad map projection appears...
